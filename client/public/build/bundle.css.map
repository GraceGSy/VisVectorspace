{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../AttributesBar.svelte",
    "../../Recommendations.svelte",
    "../../RecommendationsMain.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport * as d3 from 'd3'\n\timport AttributesBar from './AttributesBar.svelte'\n\timport RecommendationsMain from './RecommendationsMain.svelte'\n\n\tlet rand = -1;\n\tfunction getRand() {\n\t\tfetch(\"./classifier/api?param1=1&param1=2\")\n\t}\n\n\n\tlet selectedAttributes = []\n\tlet promise = loadData();\n\n\tasync function loadData() {\n\t\tconst dataset = await d3.csv(`cereal.csv`)\n\n\t\treturn dataset\n\t}\n\n\tfunction updateAttributes(event) {\n\t\tlet attribute = event.detail.attribute\n\t\t\n\t\tif (selectedAttributes.includes(attribute)) {}\n\t\telse {\n\t\t\tselectedAttributes.push(attribute)\n\t\t\tselectedAttributes = selectedAttributes\n\t\t}\n\t}\n</script>\n\n<div id=\"main\" style=\"padding: '20px'\">\n\t{#await promise}\n\t\t<p>...loading</p>\n\t{:then dataset}\n\t\t\t<AttributesBar\n\t\t\t\ton:attributeClicked={updateAttributes}\n\t\t\t\t{dataset}/>\n\t\t\t<RecommendationsMain\n\t\t\t\t{selectedAttributes}\n\t\t\t\t{dataset}/>\n\t{:catch error}\n\t\t<p style=\"color: red\">{error.message}</p>\n\t{/await}\n</div>\n\n<style>\n\t#main {\n\t\tdisplay: flex;\n\t\tflex-direction: row\n\t}\n</style>",
    "<script>\n\timport { createEventDispatcher } from 'svelte'\n\n\texport let dataset = []\n\n\t// let selectedAttributes = []\n\n\tlet attributes = Object.keys(dataset[0])\n\n\tconst dispatch = createEventDispatcher()\n\n\tfunction update(a) {\n\t\t// selectedAttributes = selectedAttributes.push(a)\n\t\tlet element = document.getElementById(a)\n\t\telement.style.backgroundColor = \"#a3ccb7\"\n\t\tdispatch('attributeClicked', {\n\t\t\tattribute: a,\n\t\t});\n\t}\n</script>\n\n<div id=\"attributesBar\">\n\t<p><b>ATTRIBUTES</b></p>\n\t{#each attributes as a}\n\t\t<button\n\t\t\tid={a}\n\t\t\ton:click={() => update(a)}>{a}</button>\n\t{/each}\n</div>\n\n<style>\n\t#attributesBar {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\twidth: 150px;\n\t\tmargin-right: 50px\n\t}\n</style>",
    "<script>\n\timport * as d3 from 'd3'\n\timport Draco from 'draco-vis'\n\timport vegaToRanking from './vegaToRanking.js'\n\timport dracoDataConstraints from './dracoDataConstraints.js'\n\timport dracoMarkConstraints from './dracoMarkConstraints.js'\n\timport dracoVisConstraints from './dracoVisConstraints.js'\n\timport defaultConstraints from './defaults.js'\n\n\timport getRecombinations from './getRecombinations.js'\n\n\texport let vegaSpecs = []\n\texport let dataset = []\n\texport let selectedAttributes = []\n\texport let recomendationCount = 9\n\t\n\tlet updateCount = 0\n\n\t// Track of user preferences\n\tlet moreLikeThis = []\n\tlet lessLikeThis = []\n\n\t// Current recommendations\n\tlet recommendations = []\n\t// Recommendations generated from the same draco query\n\tlet similarRecommendations = []\n\t// Recommendations class\n\tlet recommendationsClass = Array(9).fill(\"default\")\n\n\tlet classifierResult\n\n\tlet pinned = []\n\n\tfunction solveDraco(newConstraints) {\n\t\t// console.log(newConstraints)\n\t\tlet recs = []\n\n\t\tconst url = 'https://unpkg.com/wasm-clingo@0.2.2';\n\n\t\t// const newConstraints = getDracoConstraints()\n\t\t// console.log(newConstraints)\n\t\tlet markConstraints = dracoMarkConstraints(newConstraints)\n\t\tlet visConstraints = dracoVisConstraints(newConstraints)\n\t\t// let visConstraints = ''\n\n\t\tconst draco = new Draco(url)\n\t\treturn draco.init().then(() => {\n\t\t\t// Get metadata about dataset\n\t\t\tdraco.prepareData(dataset)\n\t\t\tconst schema = draco.getSchema()\n\t\t\tconst dataConstraints = dracoDataConstraints(schema)\n\n\t\t\t// Create constraints based on schema\n\t\t\tconst inputConstraints = `\n\t\t\t\tdata(\"cereal.csv\").\n\t\t\t\tnum_rows(77).\n\n\t\t\t\t${dataConstraints}\n\n\t\t\t\t${markConstraints}\n\n\t\t\t\t% ====== Query constraints ======\n\t\t\t\t${visConstraints}\n\t\t\t`;\n\n\t\t\tconst solution = draco.solve(inputConstraints, { models: recomendationCount });\n\t\t\tif (!solution) {\n\t\t\t\treturn \n\t\t\t}\n\n\t\t\tfor (let s of solution['specs']) {\n\t\t\t\trecs.push({'vega':s})\n\t\t\t}\n\n\t\t\tsimilarRecommendations = []\n\t\t\tsimilarRecommendations = recs\n\n\t\t\treturn recs\n\t\t})\n\t}\n\n\tfunction getSimilar(newRecommendations) {\n\t\tlet result = []\n\n\t\tfor (let nr of newRecommendations) {\n\t\t\t// console.log(nr)\n\t\t\tlet individualSpecs = vegaToRanking(nr['vega'])\n\t\t\tlet rankedSpecs = []\n\t\t\tfor (let s of Object.keys(individualSpecs)) {\n\t\t\t\tif (individualSpecs[s] !== 0) {\n\t\t\t\t\trankedSpecs.push({'attr': s, 'value': individualSpecs[s]})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(solveDraco(rankedSpecs))\n\t\t}\n\t\t\n\t\treturn result\n\t}\n\n\tfunction selectRecommendations(similarRecommendations) {\n\t\tlet allNew = []\n\n\t\tfor (let i = 0; i < 9; i++) {\n\t\t\tlet currentSet = JSON.parse(JSON.stringify(similarRecommendations[i]))\n\t\t\tif (currentSet && currentSet.length > 0) {\n\t\t\t\tcurrentSet = currentSet.filter(r => r)\n\t\t\t\tcurrentSet = currentSet.map(r => {\n\t\t\t\t\tr.index = i\n\t\t\t\t\treturn r\n\t\t\t\t})\n\t\t\t\tallNew.push(currentSet)\n\t\t\t}\n\t\t}\n\n\t\tlet result = []\n\t\tlet setNumber = 0\n\n\t\twhile (result.length < 9) {\n\t\t\tlet set = allNew[setNumber % allNew.length]\n\t\t\tlet randomIndex = Math.floor(Math.random() * (set.length))\n\t\t\tlet selected = set[randomIndex]\n\n\t\t\tif (result.length === 0) {\n\t\t\t\tresult.push(selected)\n\t\t\t} else {\n\t\t\t\tlet isNew = true\n\t\t\t\tfor (let r of result) {\n\t\t\t\t\tif (JSON.stringify(r.vega) === JSON.stringify(selected.vega)) {\n\t\t\t\t\t\tisNew = false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isNew) {\n\t\t\t\t\tresult.push(selected)\n\t\t\t\t\tsetNumber++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trecommendationsClass = recommendationsClass.map(r => 'default')\n\n\t\treturn result\n\t}\n\n\t$: {if (typeof classifierResult !== \"undefined\") {\n\t\t\tconsole.log('classifier result updated...')\n\t\t\tlet updatedPreferrences = []\n\n\t\t\tfor (let i = 0; i < classifierResult.length; i++) {\n\t\t\t\tif (i === 1) {\n\t\t\t\t\tupdatedPreferrences.push(dataset[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPromise.all(getRecombinations(vegaSpecs, updatedPreferrences)).then((result) => {\n\t\t\t\tsimilarRecommendations = result\n\t\t\t\trecommendations = selectRecommendations(result)\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction runClassifier() {\n\t\tlet testingData = vegaSpecs.map(v => v.spec)\n\t\tlet trainingData = []\n\n\t\tlet newMore = []\n\t\tlet newLess = []\n\n\t\tfor (let i = 0; i < recommendationsClass.length; i++) {\n\t\t\tlet r = recommendationsClass[i]\n\t\t\tif (r === 'more') {\n\t\t\t\tnewMore.push(recommendations[i])\n\t\t\t} else if (r === 'less') {\n\t\t\t\tnewLess.push(recommendations[i])\n\t\t\t}\n\t\t}\n\n\t\tmoreLikeThis = moreLikeThis.concat(newMore)\n\t\tlessLikeThis = lessLikeThis.concat(newLess)\n\n\t\tfor (let m of moreLikeThis) {\n\t\t\tlet newM = m.vega.encoding\n\t\t\tnewM.label = 1\n\t\t\tnewM['mark'] = m.vega.mark\n\t\t\ttrainingData.push(newM)\n\t\t}\n\t\tfor (let l of lessLikeThis) {\n\t\t\tlet newL = l.vega.encoding\n\t\t\tnewL.label = -1\n\t\t\tnewL['mark'] = l.vega.mark\n\t\t\ttrainingData.push(newL)\n\t\t}\n\n\t\tlet classifierData = {\n\t\t\t'training': trainingData,\n\t\t\t'testing': testingData\n\t\t}\n\n\t\tfetch(`./classifier`, {method:\"POST\", body:JSON.stringify(classifierData)})\n\t\t\t.then(d => d.text())\n      \t\t.then(d => (classifierResult = d))\n\t}\n\n\t$: {console.log('update count', updateCount)\n\t\tif (updateCount === 1) {\n\t\t\tPromise.all(getRecombinations(vegaSpecs, dataset)).then((result) => {\n\t\t\t\tsimilarRecommendations = result\n\t\t\t\trecommendations = selectRecommendations(result)\n\t\t\t})\n\t\t}\n\t\telse if (updateCount === 0) {}\n\t\telse {\n\t\t\tconsole.log('running classifier: ', updateCount)\n\t\t\trunClassifier()\n\t\t}}\n\n\t$: for (let rec = 0; rec < recommendations.length; rec++) {\n\t\tif (!recommendations[rec]) {continue}\n\t\tvegaEmbed(`#vis${rec}`, recommendations[rec]['vega'])\n\t}\n\n\t// Update 'moreLikeThis' array\n\tfunction updateMore(i) {\n\t\t// If items already in moreLikeThis, remove\n\t\tlet current = recommendationsClass[i]\n\t\tif (current === 'more') {\n\t\t\trecommendationsClass[i] = 'default'\n\t\t} else {\n\t\t\trecommendationsClass[i] = 'more'\n\t\t}\n\t}\n\n\t// Update 'lessLikeThis' array\n\tfunction updateLess(i) {\n\t\t// If items already in lessLikeThis, remove\n\t\tlet current = recommendationsClass[i]\n\t\tif (current === 'less') {\n\t\t\trecommendationsClass[i] = 'default'\n\t\t} else {\n\t\t\trecommendationsClass[i] = 'less'\n\t\t}\n\t}\n\n\tfunction update() {\n\t\tupdateCount++\n\t}\n\n\tfunction reset() {\n\t\trecommendationsClass = recommendationsClass.map(r => 'default')\n\t\tmoreLikeThis = []\n\t\tlessLikeThis = []\n\t}\n\n\t$: for (let p = 0; p < pinned.length; p++) {\n\t\tif (!pinned[p]) {continue}\n\t\tvegaEmbed(`#pin${p}`, pinned[p]['vega'])\n\t}\n\n\tfunction pin(i) {\n\t\tpinned = pinned.concat([recommendations[i]])\n\t}\n</script>\n\n<div>\n\t<div>\n\t\t<p><b>RECOMMENDATIONS</b></p>\n\t\t<button on:click={update}>Update Recommendations</button>\n\t\t<button on:click={reset}>Reset</button>\n\t</div>\n\t<div id=\"recommendationDisplay\">\n\t\t{#each recommendations as c, i}\n\t\t\t<div class=\"vis\">\n\t\t\t\t<button on:click={() => pin(i)}>Pin</button>\n\t\t\t\t<div>\n\t\t\t\t\t<div id=\"vis{i}\"></div>\n\t\t\t\t\t<div class=\"buttons\">\n\t\t\t\t\t\t<button class=\"{recommendationsClass[i] === 'more' ? 'more' : 'default'}\"\n\t\t\t\t\t\t\t\ton:click={() => updateMore(i)}>\n\t\t\t\t\t\t\tMore Like This\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button class=\"{recommendationsClass[i] === 'less' ? 'less' : 'default'}\"\n\t\t\t\t\t\t\t\ton:click={() => updateLess(i)}>\n\t\t\t\t\t\t\tLess Like This\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{/each}\n\t</div>\n\t<div>\n\t\t<p><b>PINNED</b></p>\n\t\t<div id=\"pinnedDisplay\">\n\t\t\t{#each pinned as p, i}\n\t\t\t\t<div id=\"pin{i}\"></div>\n\t\t\t{/each}\n\t\t</div>\n\t</div>\n</div>\n\n<style>\n\t#recommendationDisplay {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(3, 350px);\n\t\tgrid-template-rows: repeat(3, 350px);\n\t\tgrid-gap: 50px;\n\t\tmargin-top: 50px\n\t}\n\n\t#pinnedDisplay {\n\t\tdisplay: flex;\n\t\tflex-direction: row\n\t}\n\n\t.vis {\n\t\toverflow: scroll;\n\t}\n\n\t.more {\n\t\tbackground-color: #cde09b;\n\t}\n\n\t.less {\n\t\tbackground-color: #e0a99b;\n\t}\n\n\t.default {\n\t\tbackground-color: #f4f4f4;\n\t}\n</style>\n",
    "<script>\n\timport * as d3 from 'd3'\n\timport Recommendations from './Recommendations.svelte'\n\n\texport let dataset = []\n\texport let selectedAttributes = []\n\n\tlet promise = loadSpecs();\n\tlet updateCount = 0\n\n\tfunction dataPreprocessor(d) {\n\t\tlet result = {}\n\t\tfor (let i = 0; i < d3.keys(d).length; i++) {\n\t\t\tlet variableName = d3.keys(d)[i]\n\t\t\tif (variableName === 'filename') {\n\t\t\t\tresult[variableName] = d3.values(d)[i]\n\t\t\t} else {\n\t\t\t\tresult[variableName] = +d3.values(d)[i]\n\t\t\t}\n\t\t}\n\t    return result\n\t}\n\n\tasync function loadSpecs() {\n\t\tconst specs = await d3.csv(`/manual_specs_one_hot_encoding.csv`, dataPreprocessor)\n\n\t\tconst vegaSpecs = []\n\n\t\tfor (let i in specs) {\n\t\t\tif (i === 'columns') { continue; }\n\t\t\tlet s = specs[i]\n\n\t\t\tdelete s.index\n\n\t\t\t// let vegaFilename = s.filename\n\t\t\t\n\t\t\t// if (!vegaFilename) { continue }\n\t\t\t\t\n\t\t\t// vegaFilename = 'vega_examples/' + vegaFilename\n\t\t\t// const vegaSpec = await d3.json(vegaFilename)\n\t\t\tvegaSpecs.push({ 'spec':s, 'index': i })\n\t\t}\n\n\t\tprint(vegaSpecs.length)\n\n\t\treturn vegaSpecs\n\t}\n\n\t\n</script>\n\n<div id=\"recommendationsMain\">\n\t{#await promise}\n\t\t<p>...loading</p>\n\t{:then vegaSpecs}\n\t\t<Recommendations\n\t\t\t{dataset}\n\t\t\t{vegaSpecs}\n\t\t\t{selectedAttributes}\n\t\t\t{updateCount}/>\n\t{:catch error}\n\t\t<p style=\"color: red\">{error.message}</p>\n\t{/await}\n</div>\n\n<style>\n\t#recommendationsMain {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\tmargin-bottom: 150px\n\t}\n</style>"
  ],
  "names": [],
  "mappings": "AA+CC,KAAK,eAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG;CACpB,CAAC;ACnBD,cAAc,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,KAAK,CAAE,KAAK,CACZ,YAAY,CAAE,IAAI;CACnB,CAAC;ACwQD,sBAAsB,cAAC,CAAC,AACvB,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CACvC,kBAAkB,CAAE,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CACpC,QAAQ,CAAE,IAAI,CACd,UAAU,CAAE,IAAI;CACjB,CAAC,AAED,cAAc,cAAC,CAAC,AACf,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG;CACpB,CAAC,AAED,IAAI,cAAC,CAAC,AACL,QAAQ,CAAE,MAAM,AACjB,CAAC,AAED,KAAK,cAAC,CAAC,AACN,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,KAAK,cAAC,CAAC,AACN,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,QAAQ,cAAC,CAAC,AACT,gBAAgB,CAAE,OAAO,AAC1B,CAAC;ACrQD,oBAAoB,eAAC,CAAC,AACrB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,aAAa,CAAE,KAAK;CACrB,CAAC"
}