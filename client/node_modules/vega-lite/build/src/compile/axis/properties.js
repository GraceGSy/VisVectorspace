import { isArray } from 'vega-util';
import { isBinned, isBinning } from '../../bin';
import { X } from '../../channel';
import { isDiscrete, isFieldDef, isFieldDefWithCustomTimeFormat as isFieldOrDatumDefWithCustomTimeFormat, isFieldOrDatumDefForTimeFormat, toFieldDefBase, valueArray } from '../../channeldef';
import { hasDiscreteDomain } from '../../scale';
import { normalizeTimeUnit } from '../../timeunit';
import { NOMINAL, ORDINAL } from '../../type';
import { contains, normalizeAngle } from '../../util';
import { isSignalRef } from '../../vega.schema';
import { mergeTitle, mergeTitleFieldDefs } from '../common';
import { numberFormat } from '../format';
import { getAxisConfig } from './config';
export const axisRules = {
    scale: ({ model, channel }) => model.scaleName(channel),
    format: ({ fieldOrDatumDef, axis, config }) => {
        // We don't include temporal field and custom format as we apply format in encode block
        if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) || isFieldOrDatumDefWithCustomTimeFormat(fieldOrDatumDef)) {
            return undefined;
        }
        return numberFormat(fieldOrDatumDef.type, axis.format, config);
    },
    formatType: ({ fieldOrDatumDef, axis }) => {
        // As with format, we don't include temporal field and custom format here as we apply format in encode block
        if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) || isFieldOrDatumDefWithCustomTimeFormat(fieldOrDatumDef)) {
            return undefined;
        }
        const formatType = axis.formatType;
        if (formatType) {
            if (isSignalRef(formatType) || formatType === 'number' || formatType === 'time' || formatType === 'utc') {
                return formatType;
            }
        }
        return undefined;
    },
    grid: ({ fieldOrDatumDef, axis, scaleType }) => {
        var _a;
        if (isFieldDef(fieldOrDatumDef) && isBinned(fieldOrDatumDef.bin)) {
            return false;
        }
        else {
            return (_a = axis.grid) !== null && _a !== void 0 ? _a : defaultGrid(scaleType, fieldOrDatumDef);
        }
    },
    gridScale: ({ model, channel }) => gridScale(model, channel),
    labelAlign: ({ axis, labelAngle, orient, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient, channel),
    labelAngle: ({ labelAngle }) => labelAngle,
    labelBaseline: ({ axis, labelAngle, orient, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient, channel),
    labelFlush: ({ axis, fieldOrDatumDef, channel }) => { var _a; return (_a = axis.labelFlush) !== null && _a !== void 0 ? _a : defaultLabelFlush(fieldOrDatumDef.type, channel); },
    labelOverlap: ({ axis, fieldOrDatumDef, scaleType }) => { var _a; return (_a = axis.labelOverlap) !== null && _a !== void 0 ? _a : defaultLabelOverlap(fieldOrDatumDef.type, scaleType); },
    orient: ({ orient }) => orient,
    tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType }) => {
        var _a;
        const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;
        const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;
        return (_a = axis.tickCount) !== null && _a !== void 0 ? _a : defaultTickCount({ fieldOrDatumDef, scaleType, size, values: axis.values });
    },
    title: ({ axis, model, channel }) => {
        if (axis.title !== undefined) {
            return axis.title;
        }
        const fieldDefTitle = getFieldDefTitle(model, channel);
        if (fieldDefTitle !== undefined) {
            return fieldDefTitle;
        }
        const fieldDef = model.typedFieldDef(channel);
        const channel2 = channel === 'x' ? 'x2' : 'y2';
        const fieldDef2 = model.fieldDef(channel2);
        // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)
        return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
    },
    values: ({ axis, fieldOrDatumDef }) => values(axis, fieldOrDatumDef),
    zindex: ({ axis, fieldOrDatumDef, mark }) => { var _a; return (_a = axis.zindex) !== null && _a !== void 0 ? _a : defaultZindex(mark, fieldOrDatumDef); }
};
// TODO: we need to refactor this method after we take care of config refactoring
/**
 * Default rules for whether to show a grid should be shown for a channel.
 * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned
 */
export function defaultGrid(scaleType, fieldDef) {
    return !hasDiscreteDomain(scaleType) && isFieldDef(fieldDef) && !isBinning(fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.bin);
}
export function gridScale(model, channel) {
    const gridChannel = channel === 'x' ? 'y' : 'x';
    if (model.getScaleComponent(gridChannel)) {
        return model.scaleName(gridChannel);
    }
    return undefined;
}
export function getLabelAngle(model, specifiedAxis, channel, fieldOrDatumDef, axisConfigs) {
    // try axis value
    if ((specifiedAxis === null || specifiedAxis === void 0 ? void 0 : specifiedAxis.labelAngle) !== undefined) {
        return normalizeAngle(specifiedAxis === null || specifiedAxis === void 0 ? void 0 : specifiedAxis.labelAngle);
    }
    else {
        // try axis config value
        const { configValue: angle } = getAxisConfig('labelAngle', model.config, specifiedAxis === null || specifiedAxis === void 0 ? void 0 : specifiedAxis.style, axisConfigs);
        if (angle !== undefined) {
            return normalizeAngle(angle);
        }
        else {
            // get default value
            if (channel === X && contains([NOMINAL, ORDINAL], fieldOrDatumDef.type)) {
                return 270;
            }
            // no default
            return undefined;
        }
    }
}
export function defaultLabelBaseline(angle, axisOrient, channel) {
    channel = channel || (axisOrient === 'top' || axisOrient === 'bottom' ? 'x' : 'y');
    if (angle !== undefined) {
        if (channel === 'x') {
            return (45 < angle && angle < 135) || (225 < angle && angle < 315)
                ? 'middle'
                : (angle <= 45 || 315 <= angle) === (axisOrient === 'top')
                    ? 'bottom'
                    : 'top';
        }
        else {
            return angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)
                ? 'middle'
                : (45 <= angle && angle <= 135) === (axisOrient === 'left')
                    ? 'top'
                    : 'bottom';
        }
    }
    return undefined;
}
function _defaultLabelAlign(angle, axisOrient, startAngle, mainOrient) {
    // TODO: generate signal based on a similar formula if orient is a signal
    if ((angle + startAngle) % 180 === 0) {
        return 'center';
    }
    else if ((startAngle < angle && angle < 180 + startAngle) === (axisOrient === mainOrient)) {
        return 'left';
    }
    return 'right';
}
export function defaultLabelAlign(angle, axisOrient, channel) {
    channel = channel || (axisOrient === 'top' || axisOrient === 'bottom' ? 'x' : 'y');
    if (angle !== undefined) {
        if (channel === 'x') {
            return _defaultLabelAlign(angle, axisOrient, 0, 'bottom');
        }
        else {
            return _defaultLabelAlign(angle, axisOrient, 90, 'left');
        }
    }
    return undefined;
}
export function defaultLabelFlush(type, channel) {
    if (channel === 'x' && contains(['quantitative', 'temporal'], type)) {
        return true;
    }
    return undefined;
}
export function defaultLabelOverlap(type, scaleType) {
    // do not prevent overlap for nominal data because there is no way to infer what the missing labels are
    if (type !== 'nominal') {
        if (scaleType === 'log') {
            return 'greedy';
        }
        return true;
    }
    return undefined;
}
export function defaultOrient(channel) {
    return channel === 'x' ? 'bottom' : 'left';
}
export function defaultTickCount({ fieldOrDatumDef, scaleType, size, values: vals }) {
    var _a;
    if (!vals && !hasDiscreteDomain(scaleType) && scaleType !== 'log') {
        if (isFieldDef(fieldOrDatumDef)) {
            if (isBinning(fieldOrDatumDef.bin)) {
                // for binned data, we don't want more ticks than maxbins
                return { signal: `ceil(${size.signal}/10)` };
            }
            if (fieldOrDatumDef.timeUnit &&
                contains(['month', 'hours', 'day', 'quarter'], (_a = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) === null || _a === void 0 ? void 0 : _a.unit)) {
                return undefined;
            }
        }
        return { signal: `ceil(${size.signal}/40)` };
    }
    return undefined;
}
export function getFieldDefTitle(model, channel) {
    const channel2 = channel === 'x' ? 'x2' : 'y2';
    const fieldDef = model.fieldDef(channel);
    const fieldDef2 = model.fieldDef(channel2);
    const title1 = fieldDef ? fieldDef.title : undefined;
    const title2 = fieldDef2 ? fieldDef2.title : undefined;
    if (title1 && title2) {
        return mergeTitle(title1, title2);
    }
    else if (title1) {
        return title1;
    }
    else if (title2) {
        return title2;
    }
    else if (title1 !== undefined) {
        // falsy value to disable config
        return title1;
    }
    else if (title2 !== undefined) {
        // falsy value to disable config
        return title2;
    }
    return undefined;
}
export function values(axis, fieldOrDatumDef) {
    const vals = axis.values;
    if (isArray(vals)) {
        return valueArray(fieldOrDatumDef, vals);
    }
    else if (isSignalRef(vals)) {
        return vals;
    }
    return undefined;
}
export function defaultZindex(mark, fieldDef) {
    if (mark === 'rect' && isDiscrete(fieldDef)) {
        return 1;
    }
    return 0;
}
//# sourceMappingURL=properties.js.map